1. >Необязательное задание: можно посмотреть целый фильм в консоли `telnet towel.blinkenlights.nl` :)

magic :)

2. >Узнайте о том, сколько действительно независимых (не пересекающихся) каналов есть в разделяемой среде WiFi при работе на 2.4 ГГц.  
   Стандарты с полосой 5 ГГц более актуальны, но регламенты на 5 ГГц существенно различаются в разных странах, а так же не раз обновлялись. В качестве дополнительного вопроса вне зачета, попробуйте найти актуальный ответ и на этот вопрос.

*Диапазон 2,4 ГГц*

Мне понравилось как на хабре написано, очень доходчиво=) :  
"Конечно, можно заметить, что 3, 8 и 13 тоже друг другу не мешают, но, во-первых, тринадцатый можно не везде (в США всего 11 каналов),  
а во-вторых, если вы отклонитесь от мантры “1-6-11”, а кто-то другой не отклонится, то весь эффект сойдёт на нет — все каналы снова пересекутся   
и испортят друг другу жизнь. Это как обжимать витую пару — в принципе, если с двух сторон последовательность одинаковая,   
то может и заработать, только вот разбираться кому-то потом в распиновке каждой розетки будет ох как несладко. Ещё раз: **Первый. Шестой. Одиннадцатый**"

*Диапазон 5 ГГц*   
Стандартами определено 33 канала.   
Непересекающихся каналов - 19.

3. >Адрес канального уровня – MAC адрес – это 6 байт, первые 3 из которых называются OUI – Organizationally Unique Identifier или уникальный идентификатор организации. Какому производителю принадлежит MAC `38:f9:d3:55:55:79`?

![Screenshot](https://gitlab.com/SobolevES/devops-netology/-/raw/main/pics/3.1_net1.JPG)  
![Screenshot](https://gitlab.com/SobolevES/devops-netology/-/raw/main/pics/3.2_net1.JPG)

4. >Каким будет payload TCP сегмента, если Ethernet MTU задан в 9001 байт, размер заголовков IPv4 – 20 байт, а TCP – 32 байта?

Ethernet MTU (9001 байт) = ip.head (20 байт) + tcp.head (32 байта) + payload (8949 байт)  
payload TCP сегмента (8981 байт) = tcp.head (32 байта) + payload (8949 байт)  
payload = 8949 байт

Было сомнение что Ethernet MTU != MTU, думал что еще эзернет хедер и хвост добавляются, но на сайте циски нашел картинку   
![Screenshot](https://gitlab.com/SobolevES/devops-netology/-/raw/main/pics/4_net1.JPG)

5. >Может ли во флагах TCP одновременно быть установлены флаги SYN и FIN при штатном режиме работы сети? Почему да или нет?

При штатной работе TCP флаги SYN и FIN никогда не должны быть установлены одновременно ибо не безопасно, т.к. этим могут воспользоваться  
хакерюги, узнают тип твоей ОС и начнут атаку.  
"Установка флагов SYN и FIN позволяет пакету пройти через статический фильтр пакетов, так как такие фильтры блокируют только SYN-пакеты.   
Однако если такой пакет поступит на открытый порт Windows или UNIX-системы, то в ответ будет отправлен SYN/ACK-пакет."

Т.е. ответ Нет.

6. >Почему в `State` присутствует только `UNCONN`, и может ли там присутствовать, например, `TIME-WAIT`?

-u  Показывать только сокеты UDP.  
-l  Показывать слушающие сокеты.  
-a  Показывать все сокеты.

Если исходить из заданных флагов ss, то мы выводим все прослушивающие соединения UDP на 53 порту.  
А если исходить из того, что протокол UDP не устанавливает выделенного коннекта между двумя хостами, а   
связь достигается путём передачи информации в одном направлении от источника к получателю без проверки готовности или состояния получателя,  
то на вторую часть вопроса отвечаю - Нет.

7. >Обладая знаниями о том, как штатным образом завершается соединение (FIN от инициатора, FIN-ACK от ответчика, ACK от инициатора),   
   опишите в каких состояниях будет находиться TCP соединение в каждый момент времени на клиенте и на сервере при завершении.   
   Схема переходов состояния соединения вам в этом поможет.

![Screenshot](https://gitlab.com/SobolevES/devops-netology/-/raw/main/pics/7_net1.JPG)

8. >TCP порт – 16 битное число. Предположим, 2 находящихся в одной сети хоста устанавливают между собой соединения.  
   Каким будет теоретическое максимальное число соединений, ограниченное только лишь параметрами L4, которое параллельно может установить клиент с одного IP адреса к серверу с одним IP адресом?
   Сколько соединений сможет обслужить сервер от одного клиента? А если клиентов больше одного?

Схема взаимодействия клиента с сервером выглядит так  
[[ip-клиента, port-клиента] <-> [ip-сервера, port-сервера], протокол]

[ip-сервера, port-сервера, протокол] - статические переменные,  
[ip-клиента, port-клиента] - динамические.

Если исходить из того, что приложение разворачивается на сервере в 99,9% случаев на одном порту (по крайней мере я только с такими работал и разворачивал ;)),   
и ip-клиента у нас так же один, получается нам осталось определить лимит на один порт.  
Сетевой порт - это 16 бит, число от 1 до 65536.

выдержка из вики:  
"Количество портов ограничено с учётом 16-битной адресации (2^16=65536, начало — «0»).  
Все порты разделены на три диапазона — общеизвестные (или системные, 0—1023), зарегистрированные (или пользовательские, 1024—49151) и динамические (или частные, 49152—65535)."

Значит с одного ip клиента на один порт можно создать 65536 (2^16) коннектов, но здесь нужно учитывать, что  
если у клиента уже есть коннекты к другим серверам, то к нашему серверу число соединений будет за минусом уже существующих.  
Таким образом, теоретическое число соединений может быть равно    count(ip)*{count(port-client) - count(busy.port_client)} = 1*{65536-count(busy.port_client)}  
ну а максимальное со стороны клиента может быть создано 1*65536=65536коннектов

Но сервер был бы не сервером, если не регулировал все лимиты, да и физические ресурсы не резиновые.   
Сервер принимает входящее соединение и создает для него новый сокет (айпи_клиента+порт_клиента). Этот сокет является идентификатором клиента.  
А на стороне сервера уже настроены лимиты на коннекты.  
Вот у меня например:  
`vagrant@vagrant:~$ sysctl net.ipv4.ip_local_port_range`  
`net.ipv4.ip_local_port_range = 32768    60999`  
`vagrant@vagrant:~$ sysctl net.ipv4.tcp_fin_timeout`  
`net.ipv4.tcp_fin_timeout = 60`

т.е. (60999 - 32768) / 60 = 470 сокетов в секунду моя система должна обрабатывать, в чем я очень сомневаюсь :)

9. >Может ли сложиться ситуация, при которой большое число соединений TCP на хосте находятся в состоянии `TIME-WAIT`? Если да, то является ли она хорошей или плохой? Подкрепите свой ответ пояснением той или иной оценки.

Да, легко.  
Time-wait - обычное состояние из жизненного цикла TCP-соединения после закрытия сокета. ДУмаю, что даже если их будет дофига - ничего страшного, т.к.  
есть же таймер, после которого соединение закроется. Но если соединений реально много в таком статусе и уже ощущается потребление  
памяти в ядре, начинаются лаги, то думаю можно таймаут с дефолтных 60с убавить, например до 30с. И очередь быстро должна рассосаться.  
`echo 30 > /proc/sys/net/ipv4/tcp_fin_timeout`

10. >Чем особенно плоха фрагментация UDP относительно фрагментации TCP?

фрагментация - это разбиение данных (IP-датаграмма) на кусочки, передача их и в конце сбор вместе.  
Допускаемая единица передачи данных maximum transmission unit - MTU, если размер передаваемых данных более значения MTU, то происходит фрагментация.  
Например, если MTU = 1500байт, а размер нашей датаграммы превышает это значение, то маршрутизатор, который передает  
наши данные должен выполнить фрагментацию.

Если исходить из того, что TCP - это гарантированная доставка, а UDP -нет, то идем в этом направлении.  
Итак, при разбивке ip-датаграммы нагружается проц и память, т.к. процесс фрагментации создает заголовки для каждого фрагмента, но в принципе нагружает и нагружает, зато передает дальше - это я про TCP.  
А что же будет с UDP во время передачи данных более чем MTU....?!  Как только мы дойдем до фрагмента, который выпадет из датаграммы, то придется отправлять  
всю датаграмму повторно, которая должна пройти процесс фрагментации снова. Тем самым мы можем забить канал полностью.

11. >Если бы вы строили систему удаленного сбора логов, то есть систему,  
    в которой несколько хостов отправяют на центральный узел генерируемые приложениями логи (предположим, что логи – текстовая информация),   
    какой протокол транспортного уровня вы выбрали бы и почему?   
    Проверьте ваше предположение самостоятельно, узнав о стандартном протоколе `syslog`.

Вопрос мне кажется коварный :)  
Зная, как пишутся логи приложения, что за одну секунду может записаться десятки строк, а если при этом  
мы будем еще использовать TCP ... медленно ... но зато гарантированно же?)  
ТОгда UDP? Отправил и забыл! Но есть шанс, что будут потери...

В идеале для такой задачки я бы совместил эти два протокола транспортного уровня - от каждого бы взял самое лучшее.  
Например, инфу которая сыпется постоянно, например [INFO] будем отправлять через UDP, даже если и потеряем что - не беда.  
А вот [ERROR] пусть отправляются через TCP, чтобы обезопасить себя при траблшутинге.

![Screenshot](https://gitlab.com/SobolevES/devops-netology/-/raw/main/pics/11_net1.JPG)    
![Screenshot](https://gitlab.com/SobolevES/devops-netology/-/raw/main/pics/11.3_net1.JPG)  
u_dgr - сокет датаграммы unix

В kонфиге syslog все настройки перенаправлений по udp/tcp закомменчены на моей рс.

![Screenshot](https://gitlab.com/SobolevES/devops-netology/-/raw/main/pics/11.2_net1.JPG)

Предположил, что если ничего не задано в конфиге, как это у меня, то по умолчанию он все таки использует UDP по 514 порту, но судя по выводу утилит - порт свободен, да и протокол udp не используется)

12. >Сколько портов TCP находится в состоянии прослушивания на вашей виртуальной машине с Ubuntu, и каким процессам они принадлежат?

![Screenshot](https://gitlab.com/SobolevES/devops-netology/-/raw/main/pics/12_net1.JPG)

13. >Какой ключ нужно добавить в tcpdump, чтобы он начал выводить не только заголовки, но и содержимое фреймов в текстовом виде? А в текстовом и шестнадцатиричном?

-X  данные каждого пакета в 16-й форме и текстовом виде без заголовков канального уровня.  
-XX данные каждого пакета в 16-й форме и текстовом виде с заголовками канального уровня.

-A выводить все пакеты в текстовом виде; Бинарные данные ествественно будут нечитаемы.  
-e вывод заголовков канального уровня

![Screenshot](https://gitlab.com/SobolevES/devops-netology/-/raw/main/pics/13_net1.JPG)

14. >Попробуйте собрать дамп трафика с помощью tcpdump на основном интерфейсе вашей виртуальной машины и посмотреть его через tshark или Wireshark
    (можно ограничить число пакетов -c 100). Встретились ли вам какие-то установленные флаги Internet Protocol (не флаги TCP, а флаги IP)?
    Узнайте, какие флаги бывают. Как на самом деле называется стандарт Ethernet, фреймы которого попали в ваш дамп? Можно ли где-то в дампе увидеть OUI?

сделал дамп:
![Screenshot](https://gitlab.com/SobolevES/devops-netology/-/raw/main/pics/14.1_net1.JPG)

открыл его через tshark:  
![Screenshot](https://gitlab.com/SobolevES/devops-netology/-/raw/main/pics/14.4_net1.JPG)

без вербоса все грустно, поэтому открываем с флагом -V и грепаем по "Internet"   
![Screenshot](https://gitlab.com/SobolevES/devops-netology/-/raw/main/pics/14.1.1_net1.JPG)

Разбираем Internet Protocol и его флаги:  
![Screenshot](https://gitlab.com/SobolevES/devops-netology/-/raw/main/pics/14.flagsIP_net1.JPG)

флаги IPv4:  
трехбитовое поле, которое используется для управления или идентификации фрагментов. Это (в порядке убывания значимости):  
бит 0: зарезервирован; должно быть равно нулю.  
бит 1: не фрагментировать (DF)   
бит 2: Больше фрагментов (MF)  
Если установлен флаг DF и для маршрутизации пакета требуется фрагментация, то пакет отбрасывается.  
Это можно использовать при отправке пакетов на хост, у которого нет ресурсов для обработки фрагментации.  
Его также можно использовать для определения MTU пути либо автоматически программным обеспечением IP хоста,  
либо вручную с помощью диагностических инструментов, таких как ping или traceroute .  
Для нефрагментированных пакетов флаг MF сбрасывается. Для фрагментированных пакетов все фрагменты, кроме последнего,   
имеют установленный флаг MF. Последний фрагмент имеет ненулевое поле смещения фрагмента, что отличает его от нефрагментированного пакета.

![Screenshot](https://gitlab.com/SobolevES/devops-netology/-/raw/main/pics/14.ethernet_net1.JPG)   
Ethernet Version 2 или Ethernet-кадр II, ещё называемый DIX (аббревиатура первых букв фирм-разработчиков DEC, Intel, Xerox) — наиболее распространена и используется по сей день. Часто используется непосредственно протоколом Интернет.

Было смешно когда я ночью выполняя задание думал, что OUI связано с UI (User Interface), но утром посмотрел на 3задание и все стало понятно :)

![Screenshot](https://gitlab.com/SobolevES/devops-netology/-/raw/main/pics/14_OUI_net1.JPG)  


